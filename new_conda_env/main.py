import os
import sys
from pathlib import Path
import functools
from logging import getLogger
import subprocess
from subprocess import Popen, PIPE

try:
    import ruamel.yaml as yaml
except ImportError:
    try:
        import ruamel_yaml as yaml
    except ImportError:
        raise ImportError("No yaml library found. To proceed, conda install ruamel.yaml")
        
from conda.base.context import context, sys_rc_path, user_rc_path
from conda.base import constants as base_csts
from conda.common.serialize import yaml_round_trip_dump, yaml_round_trip_load
# ..........................................................................

log = getLogger(__name__)


class CondaEnvir:
    """CondaEnvir is a class that gathers basic information
    about the current conda framework in order to perform the
    'quick-clone'* of a conda environment when, e.g. a new 
    version of the (python) kernel is needed.
    [* see README.md]
    
    Arguments:
    - old_py_ver (str): Previous python version
    - new_py_ver (str): New python version
    - dotless_ver (bool): If True, period(s) in new_py_ver are removed when forming
      the default `new_env_name`
    - env_to_clone (str): The exisitng conda environment to 'quick-clone'
    - new_env_name (str, "default"): If called with default value, the new env name will
      be autogenerated as such: 'env' + self.new_py_ver
    - debug (bool, True): flag for tracing calls.
    """
    
    def __init__(self, old_py_ver: str, new_py_ver: str, dotless_ver: bool,
                 env_to_clone: str, new_env_name: str="default",
                 debug: bool=True):
        
        self.same_vers = (new_py_ver == old_py_ver)
        if self.same_vers:
            log.warning("The old & new versions are identical!")
        self.old_py_ver = old_py_ver
        self.dotless_ver = dotless_ver
        self.new_py_ver = (new_py_ver.replace('.','') if dotless_ver else new_py_ver)
 
        self.env_to_clone = env_to_clone
        self.new_env_name = self.get_new_env_name(new_env_name)
        
        self.conda_root = os.getenv("CONDA_ROOT")
        self.basic_info = self.get_conda_info()
        self.user_rc = self.get_user_rc()
        self.has_user_rc = self.user_rc is not None 
        
        self.debug = debug
        if debug:
            log.debug("Basic info:\n", f"- Root: {self.conda_root}\n",
                      f"- Info dict:\n\t{self.basic_info}")
        
        
    @staticmethod
    def get_conda_info() -> dict:
        """Return minimal number of conda-calculated 
        variables in a dict.
        All paths -> Path objects.
        """
        d = {"conda_prefix":Path(context.conda_prefix),
             "active_prefix":Path(context.active_prefix),
             "user_condarc":Path(user_rc_path),
             # only consider user's .condarc; 
             # -> relies on ordering + possibly OS: not robust -> test
             "env_dirs":Path(context.envs_dirs[0]),
             "default_python":context.default_python,
             "winOS":base_csts.on_win  # not used
            }
        return d


    def get_user_rc(self):
        p = self.basic_info["user_condarc"]
        if p.exists():
            return p
        log.info(f"No user-defined .condarc found in: {p}.")
        return None

    
    def get_new_env_name(self, str_name):
        if str_name == 'default':
            self.new_env_name ='env' + self.new_py_ver
        else:
            self.new_env_name = str_name

    
    def get_new_prefix(new_env_name: str) -> str:
        """Return the new value for the yml prefix key:
           prefix: <env_dirs>\new_env_name
        """
        env_dir = self.basic_info['env_dirs']
        if not env_dir.exists():   # needed?
            #mkdir(env_dir)??
            msg = "Conda environments folder other than "
            msg += "'<user>\Anaconda3\envs' or '<user>\miniconda3\envs'"
            msg += "are not yet supported."
            log(msg)
            raise ValueError(msg)

        return str(env_dir.joinpath(new_env_name))


    def run_conda_export(self) -> None:
        """
        WIP
        Run 
        1. `conda export` with --no-builds flag > self.env_to_clone+'_nobld'.yml
        2. `conda export` with --from-history flag > self.env_to_clone+'_hist'.yml
        """
        if self.debug:
            user_dir = Path.cwd().parent.joinpath('_temp')
        else:
            user_dir = self.basic_info['conda_prefix'].parent
        
        ok = False
        yml_nobld_path = user_dir.joinpath(test_yml_nobld)
        # create & check outcome
        yml_nobld_path.exists()

        yml_hist_path = user_dir.joinpath(test_yml_hist)
        # create & check outcome
        yml_hist_path.exists()

        return yml_hist_path, yml_nobld_path

    
    def __repr__(self):
        repr_str = f"CondaEnvir({self.old_py_ver} (str), {self.new_py_ver} (str), {self.dotless_ver} (bool), "
        repr_str += f"{self.env_to_clone} (str), {self.new_env_name} (new_env_name='default', str))"
        return repr_str.format(self.old_py_ver, self.new_py_ver, self.dotless_ver)
                        

    def __str__(self):
        return f"DOC: {self.__doc__}"

    

def load_env_yml(yml_filepath: Path):
    return yaml_round_trip_load(yml_filepath)   
    
